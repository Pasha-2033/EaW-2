#Created by lead programmer of EaW 2 (vk: @uber_medic, @communistic_sistema)
#vesrion 1.0
#use MTTH implementation instead of scriped effects, less code, write code with pleasure :)

#usage:
#set_variable = { global.math_args^0 }
#set_temp_variable = { temp = mtth:ceil }
#if you want to use other functions - use this table:
#	tg = sin/cos
#	ctg = 1/tg
#	sec = 1/cos
#	csc = 1/sin
#	arccos = pi/2 - arcsin
#	arcctg = pi/2 - arctg
#	arccsc = arcsin(1/x)
#	sinh = (e^x - e^-x) / 2
#	cosh = (e^x + e^-x) / 2
#	sinh/cosh = (e^x - e^-x) / (e^x + e^-x) = (e^2x - 1) / (e^2x + 1)

ceil = {
	#argument for ceil(x): x -> global.math_args^0
	base = 0
	modifier = {
		set_temp_variable = {
			temp = global.math_args^0
		}
		round_temp_variable = temp
		if = {
			limit = {
				check_variable = {
					temp < global.math_args^0
				}
			}
			add_to_temp_variable = {
				temp = 1
			}
		}
		add = temp
	}
}
floor = {
	#argument for floor(x): x -> global.math_args^0
	base = 0
	modifier = {
		set_temp_variable = {
			temp = global.math_args^0
		}
		round_temp_variable = temp
		if = {
			limit = {
				check_variable = {
					temp > global.math_args^0
				}
			}
			subtract_from_temp_variable = {
				temp = 1
			}
		}
		add = temp
	}
}
division_without_remainder = {
	#arguments for x // y: x -> global.math_args^0, y -> global.math_args^1
	base = 0
	modifier = {
		set_temp_variable = {
			temp_0 = global.math_args^0
		}
		divide_temp_variable = {
			temp_0 = global.math_args^1
		}
		round_temp_variable = temp_0
		set_temp_variable = {
			temp_1 = temp_0
		}
		multiply_temp_variable = {
			temp_1 = global.math_args^1
		}
		if = {
			limit = {
				check_variable = {
					temp_1 > global.math_args^0
				}
			}
			subtract_from_temp_variable = {
				temp_0 = 1
			}
		}
		add = temp_0
	}
}
remainder_of_division = {
	#arguments for x % y: x -> global.math_args^0, y -> global.math_args^1
	base = 0
	modifier = {
		set_temp_variable = {
			temp_0 = global.math_args^0
		}
		divide_temp_variable = {
			temp_0 = global.math_args^1
		}
		round_temp_variable = temp_0
		set_temp_variable = {
			temp_1 = temp_0
		}
		multiply_temp_variable = {
			temp_1 = global.math_args^1
		}
		if = {
			limit = {
				check_variable = {
					temp_1 > global.math_args^0
				}
			}
			subtract_from_temp_variable = {
				temp_0 = 1
			}
		}
		set_temp_variable = {
			temp_1 = global.math_args^0
		}
		multiply_temp_variable = {
			temp_0 = global.math_args^1
		}
		subtract_from_temp_variable = {
			temp_1 = temp_0
		}
		add = temp_1
	}
}
#ln - wait in version 1.1
#exp - wait in version 1.1
abs = {
	#argument for abs(x): x -> global.math_args^0
	base = 0
	modifier = {
		set_temp_variable = {
			temp = global.math_args^0
		}
		if = {
			limit = {
				check_variable = {
					temp < 0
				}
			}
			multiply_temp_variable = {
				temp = -1
			}
		}
		add = temp
	}
}
#sqrt - wait in version 1.1
#sqrt(x, n) - wait in version 1.1
sin = {
	#argument for sin(x): x -> global.math_args^0 in radians
	base = 0
	modifier = {
		set_temp_variable = {
			x = global.math_args^0
		}
		set_temp_variable = {
			n2x = x
		}
		multiply_temp_variable = {
			n2x = n2x
		}
		multiply_temp_variable = {
			n2x = -1
		}
		set_temp_variable = {
			sum = x
		}
		#any loop doesn`t work, so there is cycles
		#cycle 1
		divide_temp_variable = {
			x = 6
		}
		multiply_temp_variable = {
			x = n2x
		}
		add_to_temp_variable = {
			sum = x
		}
		#cycle 2
		divide_temp_variable = {
			x = 20
		}
		multiply_temp_variable = {
			x = n2x
		}
		add_to_temp_variable = {
			sum = x
		}
		#cycle 3
		divide_temp_variable = {
			x = 42
		}
		multiply_temp_variable = {
			x = n2x
		}
		add_to_temp_variable = {
			sum = x
		}
		#cycle 4
		divide_temp_variable = {
			x = 72
		}
		multiply_temp_variable = {
			x = n2x
		}
		add_to_temp_variable = {
			sum = x
		}
		#cycle 5
		divide_temp_variable = {
			x = 110
		}
		multiply_temp_variable = {
			x = n2x
		}
		add_to_temp_variable = {
			sum = x
		}
		add = sum
	}
}
cos = {
	base = 0
	modifier = {
		#argument for cos(x): x -> global.math_args^0 in radians
		set_temp_variable = {
			n2x = global.math_args^0
		}
		multiply_temp_variable = {
			n2x = n2x
		}
		multiply_temp_variable = {
			n2x = -1
		}
		set_temp_variable = {
			counter_0 = 1
		}
		set_temp_variable = {
			sum = 1
		}
		set_temp_variable = {
			temp = 1
		}
		#any loop doesn`t work, so there is cycles
		#cycle 1
		multiply_temp_variable = {
			temp = n2x
		}
		divide_temp_variable = {
			temp = 2
		}
		add_to_temp_variable = {
			sum = temp
		}
		#cycle 2
		multiply_temp_variable = {
			temp = n2x
		}
		divide_temp_variable = {
			temp = 12 
		}
		add_to_temp_variable = {
			sum = temp
		}
		#cycle 3
		multiply_temp_variable = {
			temp = n2x
		}
		divide_temp_variable = {
			temp = 30 
		}
		add_to_temp_variable = {
			sum = temp
		}
		#cycle 4
		multiply_temp_variable = {
			temp = n2x
		}
		divide_temp_variable = {
			temp = 56 
		}
		add_to_temp_variable = {
			sum = temp
		}
		#cycle 5
		multiply_temp_variable = {
			temp = n2x
		}
		divide_temp_variable = {
			temp = 90 
		}
		add_to_temp_variable = {
			sum = temp
		}
		add = sum
	}
}
arcsin = {
	#argument for arcsin(x): x -> global.math_args^0 in radians
	base = 0
	modifier = {
		set_temp_variable = {
			x = global.math_args^0
		}
		set_temp_variable = {
			2x = x
		}
		multiply_temp_variable = {
			2x = x
		}
		set_temp_variable = {
			sum = x
		}
		#any loop doesn`t work, so there is cycles
		#cycle 1
		multiply_temp_variable = {
			x = 2x
		}
		set_temp_variable = {
			temp_x = x
		}
		divide_temp_variable = {
			temp_x = 6
		}
		add_to_temp_variable = {
			sum = temp_x
		}
		#cycle 2
		multiply_temp_variable = {
			x = 2x
		}
		set_temp_variable = {
			temp_x = x
		}
		multiply_temp_variable = {
			temp_x = 0.075
		}
		add_to_temp_variable = {
			sum = temp_x
		}
		#cycle 3
		multiply_temp_variable = {
			x = 2x
		}
		set_temp_variable = {
			temp_x = x
		}
		divide_temp_variable = {
			temp_x = 22.4
		}
		add_to_temp_variable = {
			sum = temp_x
		}
		#cycle 4
		multiply_temp_variable = {
			x = 2x
		}
		set_temp_variable = {
			temp_x = x
		}
		divide_temp_variable = {
			temp_x = 32.914
		}
		add_to_temp_variable = {
			sum = temp_x
		}
		add = sum
	}
}
arctg = {
	base = 0
	modifier = {
		#argument for arctg(x): x -> global.math_args^0 in radians
		#limit! x^2<=1
		set_temp_variable = {
			x = global.math_args^0
		}
		set_temp_variable = {
			n2x = x
		}
		multiply_temp_variable = {
			n2x = n2x
		}
		multiply_temp_variable = {
			n2x = -1
		}
		set_temp_variable = {
			sum = x
		}
		#any loop doesn`t work, so there is cycles
		#cycle 1
		multiply_temp_variable = {
			x = n2x
		}
		add_to_temp_variable = {
			sum = x
		}
		#cycle 2
		multiply_temp_variable = {
			x = n2x
		}
		set_temp_variable = {
			temp = x
		}
		divide_temp_variable = {
			temp = 3
		}
		add_to_temp_variable = {
			sum = temp
		}
		#cycle 3
		multiply_temp_variable = {
			x = n2x
		}
		set_temp_variable = {
			temp = x
		}
		divide_temp_variable = {
			temp = 5
		}
		add_to_temp_variable = {
			sum = temp
		}
		#cycle 4
		multiply_temp_variable = {
			x = n2x
		}
		set_temp_variable = {
			temp = x
		}
		divide_temp_variable = {
			temp = 7
		}
		add_to_temp_variable = {
			sum = temp
		}
		#cycle 5
		multiply_temp_variable = {
			x = n2x
		}
		set_temp_variable = {
			temp = x
		}
		divide_temp_variable = {
			temp = 9
		}
		add_to_temp_variable = {
			sum = temp
		}
		add = sum
	}
}